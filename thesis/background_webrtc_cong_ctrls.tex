\section{WebRTC Congestion controls}
Video data by nature is large in size so transmitting it creates a lot of traffic. 
This makes real- time communication challenging because it requires low latency in order to assure a good user experience. 

History and previous research [cite relevant stuff, like congestion collapse]has shown that protocols should employ mechanisms that limit the amount of data sent per second to a reasonable level in order to avoid congestion as well as keep the latency low.
\subsection{Google Congestion Control}
RTP by itself only provides simple end- to- end delivery services for multimedia[cite RTP standard], since real- time communication requires congestion control it must implemented on top of RTP. 
Chromium's WebRTC implementation uses an algorithm called Google Congestion Control \cite{draft-ietf-rmcat-gcc} to provide the mechanism.
It consists of two controllers, one loss- based and one delay- based. 
The loss- based controller located on the sender- side, uses loss rate, RTT and REMB[Cite REMB message definition] messages to compute a target sending bitrate. 
The delay- based controller can either be implemented on the receiver- side or sender- side.
It uses packet arrival info to compute a maximum bitrate which is passed to the loss- based controller. The actual sending rate is set to the minimum of the two bitrates.
% Might want to explain RTP terms like groups of packets and etc. 
\subsubsection{The loss- based controller}
The loss- based controller is run every time a feedback message from the receiver- side is received. 
If more than 10\% of packets have been lost when feedback is received the controller decreases the estimate. 
If less than 2\% is lost it will increase the estimate under the presumption that there is more bandwidth to utilize. 
Otherwise the estimate stays the same.
\subsubsection{The delay- based controller}
 The delay- based controller consists of several parts: pre- filtering, an arrival- time filter, an over- use detector and a rate controller. %% probably smart to have a figure of this

 Pre- filtering is used to make sure that channel outages, events unrelated to congestion are not interpreted as congestion.
Packets will naturally be delayed when a channel outage occurs so without this filter the algorithm would unnecessarily lower bitrate, thus lowering the quality of the communication for no reason.
A channel outage will cause the packets to be queued in network buffers, thus when the channel is restored the packets will arrive in bursts. 
The filter utilizes the fact that the packet groups will arrive in bursts during a channel outage and merges them under such conditions.

The arrival- time filter is responsible for calculating the queueing time variation which is an estimation of how the delay is developing at a certain time.
%TODO: fill this one with more info
The goal of the over- use detector is to produce a signal that drives the state of the remote rate controller. 
The goal of the over- use detector is to compare the queueing time variation obtained as output from the arrival- time filter with a threshold. If the estimate is above the threshold for a certain amount of time and not sinking it wil signal the rate contol.
%TODO: incorporate explaination of the remote rate controller as well as the related state machine and how it works
\subsubsection{Performance}
\subsection{NADA}
Network-Assisted Dynamic Adaptation (NADA) \cite{XiaoqingZhu2013NAUC} specified in \cite{rfc8698} is a proposed congestion control for WebRTC designed by Cisco.
The key design goal of NADA is to offer both fast adaption time to congestion whilst also being able to compete with TCP flows sharing the same bottleneck.
In order to achieve this, NADA combines loss, delay and ECN marked packets into a composite network congestion signal.
\subsubsection{System overview}
%TODO: probably nice with a figure of the system
We will first give a basic overview of the central components of the system, then explain each of them afterwards more thoroughly.
%Live video encoder
The live video encoder is a component responsible for encoding incoming raw video frames into RTP packets.
It tries to output RTP packets at a rate as close as possible to the target input rate $R_v$ decided by the rate control. 
The actual output rate is denoted by $R_o$ which will be a number within a range $[R_{min},R_{max}]$ depending on the video scene complexity and can change over time.
The value of the output rate $R_o$ may fluctuate randomly around the input target rate $R_v$.
On top of that the live video encoder is only capable of reacting to changes in $R_v$ over long time intervals that might be in the order of seconds.
The encoder's typical reaction time is denoted by $T_v$.
%NADA sending agent
The NADA sending agent has the responsibility of calculating a reference rate $R_n$ based on the composite congestion signal reported by the receiver. 
The reference rate calculated by the sending agent is then used to regulate the video sending rate $R_s$.
However there will be a difference between actual video encoder ouput and regulated send rate, a rate shaping buffer is used to absorb that difference.
The size of the buffer $L_s$ along with $R_n$ determine the video encoder target rate and the sending rate. 
%Network node
NADA is designed to work with nodes in different operation modes and it support many different queueing modes.
%NADA receiving agent
The NADA receiving agent is responsible for calculating the composite congestion signal used by the sending agent to regulate the sending rate. 
To do this it uses derived one- way delay of each packet, loss events and ECN markings.
The one- way delay $D_n$ is derived from RTP header timestamps while ECN markings are extracted from the IP headers. 
The resulting composite signal is in the form of an "equivalent delay" $~d_n$.
A time smoothed version $x_n$ of the signal is periodically reported back to the sending agent through RTCP messages.

%TODO: a table of symbols might be nice
\subsubsection{Receiver agent}
The receiver agent has four main tasks: 
a) Monitor one- way delay, packet loss and gather ECN marking statistics. 
b) Aggregate the different congestion signals into a composite network congestion signal. 
c) Calculate a time- smoothed value of the composite congestion signal. 
d) Send periodic reports of congestion to the sender.
\paragraph{a. Monitoring one- way delay, packet loss and gathering ECM marking statistics}
\paragraph{b. Aggregating different congestion signals into a composite network congestion signal}
\paragraph{c. Calculating a time- smoothed value}
\paragraph{d. Sending reports of congestion to the sender}

\subsubsection{Sender agent}
\subsubsection{Performance}
\subsubsection{Usage}

\subsection{SCReAM}
