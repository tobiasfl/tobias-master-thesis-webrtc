\documentclass[UKenglish]{ifimaster}
\usepackage[utf8]{inputenc}           %% ... or latin1
\usepackage[T1]{fontenc,url}
\urlstyle{sf}
\usepackage{babel,textcomp,csquotes,duomasterforside,varioref,graphicx}
\usepackage[backend=biber,style=numeric-comp]{biblatex}
\usepackage[hidelinks]{hyperref}

\title{Awesome title here}       
\subtitle{Managing Real- Time Video and Data Flows with Coupled Congestion Control Mechanism}
\author{Tobias Fladby}                     

\addbibresource{./bibdb/mybib.bib}           

\begin{document}
\duoforside[dept={Department of Informatics},   %% ... or your department
  program={programming and system architecture},  %% ... or your programme
  long]                                       

\frontmatter{}
\chapter*{Abstract}            

\tableofcontents{}
\listoffigures{}
\listoftables{}

\chapter*{Preface}              

\mainmatter{}
\chapter{Introduction}              

\section{Problem statement}
\section{Contributions}
\section{Research questions}
\emph{Overall:}
\begin{itemize}
    \item Can two heterogenous control mechanisms be coupled? Will it improve overall performance?
\end{itemize}
\emph{Simplicity:}
\begin{itemize}
    \item Can such a mechanism be designed simple enough for widespread implementation? Moreover can it be easily integrated with other congestion control mechanisms? 
\end{itemize}
\emph{Fairness:}
\begin{itemize}
    \item Will both flows get their allocated share of bandwidth when needed?
    \item Will the coupled flows be fair to other flows sharing the same bottleneck?
    \item Will the bandwidth be shared according to configured priority?
\end{itemize}
\emph{Delay:}
\begin{itemize}
    \item Can it reduce delay spikes?
\end{itemize}
\emph{Link utilization:}
\begin{itemize}
    \item Will link utilization be equal to a single flow using the full link?
\end{itemize}
\emph{Responsiveness:}
\begin{itemize}
    \item Will any of the congestion control mechanisms be more responsive to congestion in the network?
\end{itemize}
\emph{Packet loss:}
\begin{itemize}
    \item Will any of the flows experience less packet loss?
    \item Can it reduce packet loss spikes for the flows?
\end{itemize}

\section{Organization}

\chapter{Background}

\section{WebRTC architecture}
\subsection{Real- time communication}
\subsection{Standardization}
\subsection{Protocol Stack}
\subsection{User API}
\subsubsection{Services}
\subsubsection{RTCPeerConnection API}
\subsubsection{DataChannel API}
\subsection{Signalling}
\subsubsection{NAT}
\subsubsection{ICE Framework}
\subsubsection{TURN}
\subsubsection{STUN}
\subsubsection{SDP}
\subsection{Encryption}
\subsubsection{TLS}
\subsubsection{DTLS}
\subsection{Usage}
\subsection{Browser engine}
\subsubsection{Aquiring WebRTC statistics}

\section{Transport protocols}
\subsection{TCP}
\subsection{UDP}
\subsubsection{Message- oriented protocols}
\subsection{RTP and RTCP}
\subsection{SCTP}
SCTP is a transport protocol offering many of the same services as TCP while also bringing additional features and improvements to the table. 
SCTP also offers a point- to- point connection- oriented reliable delivery service while also using the same flow and congestion control algorithms as TCP.   %cite RFC perhaps
As opposed to TCP, SCTP is message- oriented. %explain more
A SCTP connections is called an association.

SCTP separates application data into chunks, each identified by a separate chunk header. 
These chunks are bundled into a single SCTP message that consists of an SCTP message header followed by several data chunks.
A key feature here is that the data chunks are independently identified with a separate header, thus a single SCTP message can contain data from separate streams of application data. For example one stream being text messages and another being the transfer of a file in a messaging application.
The advantage of this packet structure is that it means SCTP can support multi- streaming since it can send multiple data streams in parallel through a single SCTP association. 
%TODO: have a small section explaining head- of- line blocking and how SCTP avoids it 

Multi- streaming means that an application can transmit several independent streams of data in parallel. 

SCTP separates application data into chunks, each identified by a separate header. 
A single SCTP packet can contain several data chunks from different application data streams.

%TODO:cite some of the papers that have shown SCTP improvements compared to TCP 

\section{Congestion control}
\subsection{Loss- based congestion control}
\subsection{Delay- based congestion control}
\section{WebRTC Congestion controls}
Video data by nature is large in size so transmitting it creates a lot of traffic. 
This makes real- time communication challenging because it requires low latency in order to assure a good user experience. 

History and previous research [cite relevant stuff, like congestion collapse]has shown that protocols should employ mechanisms that limit the amount of data sent per second to a reasonable level in order to avoid congestion as well as keep the latency low.
\subsection{Google Congestion Control}
RTP by itself only provides simple end- to- end delivery services for multimedia[cite RTP standard], since real- time communication requires congestion control it must implemented on top of RTP. 
Chromium's WebRTC implementation uses an algorithm called Google Congestion Control \cite{draft-ietf-rmcat-gcc} to provide the mechanism.
It consists of two controllers, one loss- based and one delay- based. 
The loss- based controller located on the sender- side, uses loss rate, RTT and REMB[Cite REMB message definition] messages to compute a target sending bitrate. 
The delay- based controller can either be implemented on the receiver- side or sender- side.
It uses packet arrival info to compute a maximum bitrate which is passed to the loss- based controller. The actual sending rate is set to the minimum of the two bitrates.
% Might want to explain RTP terms like groups of packets and etc. 
\subsubsection{The loss- based controller}
The loss- based controller is run every time a feedback message from the receiver- side is received. 
If more than 10\% of packets have been lost when feedback is received the controller decreases the estimate. 
If less than 2\% is lost it will increase the estimate under the presumption that there is more bandwidth to utilize. 
Otherwise the estimate stays the same.
\subsubsection{The delay- based controller}
 The delay- based controller consists of several parts: pre- filtering, an arrival- time filter, an over- use detector and a rate controller. %% probably smart to have a figure of this

 Pre- filtering is used to make sure that channel outages, events unrelated to congestion are not interpreted as congestion.
Packets will naturally be delayed when a channel outage occurs so without this filter the algorithm would unnecessarily lower bitrate, thus lowering the quality of the communication for no reason.
A channel outage will cause the packets to be queued in network buffers, thus when the channel is restored the packets will arrive in bursts. 
The filter utilizes the fact that the packet groups will arrive in bursts during a channel outage and merges them under such conditions.

The arrival- time filter is responsible for calculating the queueing time variation which is an estimation of how the delay is developing at a certain time.
%TODO: fill this one with more info
The goal of the over- use detector is to produce a signal that drives the state of the remote rate controller. 
The goal of the over- use detector is to compare the queueing time variation obtained as output from the arrival- time filter with a threshold. If the estimate is above the threshold for a certain amount of time and not sinking it wil signal the rate contol.
%TODO: incorporate explaination of the remote rate controller as well as the related state machine and how it works
\subsubsection{Performance}
\subsection{NADA}
%Sytem overview
\subsubsection{Overview}
\subsubsection{Receiver agent}

\subsubsection{Sender agent}

\subsection{Scream}


\section{Coupled Congestion Control}
\subsection{Problems with combined controls}
%TODO: talk and read about the old type mentioned in the articles
Coupled congestion control \cite{rfc8699} is a mechanism that aims to improve the delay, loss and fairness for flows travelling over the same bottlenecks by combining their congestion controls. 
%TODO: Explain why this could prove useful for WebRTC
%TODO: read about how it performs and cite/mention it around here
The system has two main components, the Shared Bottleneck Detection(SBD) and the Flow State Exchange(FSE). 
\subsection{Managing flows}
\subsection{The Flow State Exchange}
The FSE can be described as a manager that maintains information about the flows and hands out the allowed bit rate for each flow depending on several factors. 
Firstly, it takes into account how many other flows that are sharing a bottleneck, to make this possible every flow register themselves with the FSE and SBD when they start. 
For each flow FSE also keeps stores a priority number, the rate used by the flow and the desired rate of the flow. 
%TODO: more...

\section{Shared Bottleneck Detection}
The SBD is an entity that is responsible for determining which flows are traversing the same bottleneck. 
In \cite{rfc8699} three methods for deriving if flows share the same bottleneck are mentioned.
\subsection{Multiplexed flows}
One way is through comparing multiplexed flows. 
%TODO: might want to explain the term five- tuple
Since the flows with the same five- tuple will be routed along the same path, SBD can assume that they share the same bottleneck. 
However this method cannot be used for coupled congestion controllers with one sender talking to multiple receivers, given that they will not have the same five- tuple. 
Since WebRTC uses both SRTP and SCTP multiplexed on UDP, this implies they have the same five- tuple and that the first method will work. 
\subsection{Measurement}
One might also use measurements of e.g. delay and loss and look at correlations to derive if flows have a shared bottleneck.
\subsection{Configuration}


\chapter{Design}

\chapter{Implementation}                 


\chapter{Evaluation}
\section{Testbed}
\section{Experiments}

\chapter{Conclusion}                    
\section{Research Findings}
\section{Further work}
\section{Closing remarks}

\backmatter{}
\printbibliography
\end{document}
